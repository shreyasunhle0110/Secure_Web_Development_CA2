{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, EventEmitter, Component, Input, HostBinding, Output, NgModule, forwardRef, Directive, HostListener } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { of, BehaviorSubject, Subject } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\n\n/** @deprecated Use `LOADER_OPTIONS` instead. See `RecaptchaLoaderOptions.onBeforeLoad` */\nconst RECAPTCHA_LANGUAGE = new InjectionToken(\"recaptcha-language\");\n/** @deprecated Use `LOADER_OPTIONS` instead. See `RecaptchaLoaderOptions.onBeforeLoad` */\nconst RECAPTCHA_BASE_URL = new InjectionToken(\"recaptcha-base-url\");\n/** @deprecated Use `LOADER_OPTIONS` instead. See `RecaptchaLoaderOptions.onBeforeLoad` */\nconst RECAPTCHA_NONCE = new InjectionToken(\"recaptcha-nonce-tag\");\nconst RECAPTCHA_SETTINGS = new InjectionToken(\"recaptcha-settings\");\nconst RECAPTCHA_V3_SITE_KEY = new InjectionToken(\"recaptcha-v3-site-key\");\n/**\n * See the documentation for `RecaptchaLoaderOptions`.\n */\nconst RECAPTCHA_LOADER_OPTIONS = new InjectionToken(\"recaptcha-loader-options\");\nfunction loadScript(renderMode, onBeforeLoad, onLoaded, {\n  url,\n  lang,\n  nonce\n} = {}) {\n  window.ng2recaptchaloaded = () => {\n    onLoaded(grecaptcha);\n  };\n  const script = document.createElement(\"script\");\n  script.innerHTML = \"\";\n  const {\n    url: baseUrl,\n    nonce: onBeforeLoadNonce\n  } = onBeforeLoad(new URL(url || \"https://www.google.com/recaptcha/api.js\"));\n  baseUrl.searchParams.set(\"render\", renderMode === \"explicit\" ? renderMode : renderMode.key);\n  baseUrl.searchParams.set(\"onload\", \"ng2recaptchaloaded\");\n  baseUrl.searchParams.set(\"trustedtypes\", \"true\");\n  if (lang) {\n    baseUrl.searchParams.set(\"hl\", lang);\n  }\n  script.src = baseUrl.href;\n  const nonceValue = onBeforeLoadNonce || nonce;\n  if (nonceValue) {\n    script.setAttribute(\"nonce\", nonceValue);\n  }\n  script.async = true;\n  script.defer = true;\n  document.head.appendChild(script);\n}\nfunction newLoadScript({\n  v3SiteKey,\n  onBeforeLoad,\n  onLoaded\n}) {\n  const renderMode = v3SiteKey ? {\n    key: v3SiteKey\n  } : \"explicit\";\n  loader.loadScript(renderMode, onBeforeLoad, onLoaded);\n}\nconst loader = {\n  loadScript,\n  newLoadScript\n};\nfunction toNonNullObservable(subject) {\n  return subject.asObservable().pipe(filter(value => value !== null));\n}\nlet RecaptchaLoaderService = /*#__PURE__*/(() => {\n  class RecaptchaLoaderService {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static {\n      this.ready = null;\n    }\n    constructor(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId,\n    // eslint-disable-next-line deprecation/deprecation\n    language,\n    // eslint-disable-next-line deprecation/deprecation\n    baseUrl,\n    // eslint-disable-next-line deprecation/deprecation\n    nonce, v3SiteKey, options) {\n      this.platformId = platformId;\n      this.language = language;\n      this.baseUrl = baseUrl;\n      this.nonce = nonce;\n      this.v3SiteKey = v3SiteKey;\n      this.options = options;\n      const subject = this.init();\n      this.ready = subject ? toNonNullObservable(subject) : of();\n    }\n    /** @internal */\n    init() {\n      if (RecaptchaLoaderService.ready) {\n        return RecaptchaLoaderService.ready;\n      }\n      if (!isPlatformBrowser(this.platformId)) {\n        return undefined;\n      }\n      const subject = new BehaviorSubject(null);\n      RecaptchaLoaderService.ready = subject;\n      loader.newLoadScript({\n        v3SiteKey: this.v3SiteKey,\n        onBeforeLoad: url => {\n          if (this.options?.onBeforeLoad) {\n            return this.options.onBeforeLoad(url);\n          }\n          const newUrl = new URL(this.baseUrl ?? url);\n          if (this.language) {\n            newUrl.searchParams.set(\"hl\", this.language);\n          }\n          return {\n            url: newUrl,\n            nonce: this.nonce\n          };\n        },\n        onLoaded: recaptcha => {\n          let value = recaptcha;\n          if (this.options?.onLoaded) {\n            value = this.options.onLoaded(recaptcha);\n          }\n          subject.next(value);\n        }\n      });\n      return subject;\n    }\n    static {\n      this.ɵfac = function RecaptchaLoaderService_Factory(t) {\n        return new (t || RecaptchaLoaderService)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(RECAPTCHA_LANGUAGE, 8), i0.ɵɵinject(RECAPTCHA_BASE_URL, 8), i0.ɵɵinject(RECAPTCHA_NONCE, 8), i0.ɵɵinject(RECAPTCHA_V3_SITE_KEY, 8), i0.ɵɵinject(RECAPTCHA_LOADER_OPTIONS, 8));\n      };\n    }\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: RecaptchaLoaderService,\n        factory: RecaptchaLoaderService.ɵfac\n      });\n    }\n  }\n  return RecaptchaLoaderService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId = 0;\nlet RecaptchaComponent = /*#__PURE__*/(() => {\n  class RecaptchaComponent {\n    constructor(elementRef, loader, zone, settings) {\n      this.elementRef = elementRef;\n      this.loader = loader;\n      this.zone = zone;\n      this.id = `ngrecaptcha-${nextId++}`;\n      this.errorMode = \"default\";\n      this.resolved = new EventEmitter();\n      /**\n       * @deprecated `(error) output will be removed in the next major version. Use (errored) instead\n       */\n      // eslint-disable-next-line @angular-eslint/no-output-native\n      this.error = new EventEmitter();\n      this.errored = new EventEmitter();\n      if (settings) {\n        this.siteKey = settings.siteKey;\n        this.theme = settings.theme;\n        this.type = settings.type;\n        this.size = settings.size;\n        this.badge = settings.badge;\n      }\n    }\n    ngAfterViewInit() {\n      this.subscription = this.loader.ready.subscribe(grecaptcha => {\n        if (grecaptcha != null && grecaptcha.render instanceof Function) {\n          this.grecaptcha = grecaptcha;\n          this.renderRecaptcha();\n        }\n      });\n    }\n    ngOnDestroy() {\n      // reset the captcha to ensure it does not leave anything behind\n      // after the component is no longer needed\n      this.grecaptchaReset();\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    /**\n     * Executes the invisible recaptcha.\n     * Does nothing if component's size is not set to \"invisible\".\n     */\n    execute() {\n      if (this.size !== \"invisible\") {\n        return;\n      }\n      if (this.widget != null) {\n        void this.grecaptcha.execute(this.widget);\n      } else {\n        // delay execution of recaptcha until it actually renders\n        this.executeRequested = true;\n      }\n    }\n    reset() {\n      if (this.widget != null) {\n        if (this.grecaptcha.getResponse(this.widget)) {\n          // Only emit an event in case if something would actually change.\n          // That way we do not trigger \"touching\" of the control if someone does a \"reset\"\n          // on a non-resolved captcha.\n          this.resolved.emit(null);\n        }\n        this.grecaptchaReset();\n      }\n    }\n    /**\n     * ⚠️ Warning! Use this property at your own risk!\n     *\n     * While this member is `public`, it is not a part of the component's public API.\n     * The semantic versioning guarantees _will not be honored_! Thus, you might find that this property behavior changes in incompatible ways in minor or even patch releases.\n     * You are **strongly advised** against using this property.\n     * Instead, use more idiomatic ways to get reCAPTCHA value, such as `resolved` EventEmitter, or form-bound methods (ngModel, formControl, and the likes).å\n     */\n    get __unsafe_widgetValue() {\n      return this.widget != null ? this.grecaptcha.getResponse(this.widget) : null;\n    }\n    /** @internal */\n    expired() {\n      this.resolved.emit(null);\n    }\n    /** @internal */\n    onError(args) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.error.emit(args);\n      this.errored.emit(args);\n    }\n    /** @internal */\n    captchaResponseCallback(response) {\n      this.resolved.emit(response);\n    }\n    /** @internal */\n    grecaptchaReset() {\n      if (this.widget != null) {\n        this.zone.runOutsideAngular(() => this.grecaptcha.reset(this.widget));\n      }\n    }\n    /** @internal */\n    renderRecaptcha() {\n      // This `any` can be removed after @types/grecaptcha get updated\n      const renderOptions = {\n        badge: this.badge,\n        callback: response => {\n          this.zone.run(() => this.captchaResponseCallback(response));\n        },\n        \"expired-callback\": () => {\n          this.zone.run(() => this.expired());\n        },\n        sitekey: this.siteKey,\n        size: this.size,\n        tabindex: this.tabIndex,\n        theme: this.theme,\n        type: this.type\n      };\n      if (this.errorMode === \"handled\") {\n        renderOptions[\"error-callback\"] = (...args) => {\n          this.zone.run(() => this.onError(args));\n        };\n      }\n      this.widget = this.grecaptcha.render(this.elementRef.nativeElement, renderOptions);\n      if (this.executeRequested === true) {\n        this.executeRequested = false;\n        this.execute();\n      }\n    }\n    static {\n      this.ɵfac = function RecaptchaComponent_Factory(t) {\n        return new (t || RecaptchaComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(RecaptchaLoaderService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RECAPTCHA_SETTINGS, 8));\n      };\n    }\n    static {\n      this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n        type: RecaptchaComponent,\n        selectors: [[\"re-captcha\"]],\n        hostVars: 1,\n        hostBindings: function RecaptchaComponent_HostBindings(rf, ctx) {\n          if (rf & 2) {\n            i0.ɵɵattribute(\"id\", ctx.id);\n          }\n        },\n        inputs: {\n          id: \"id\",\n          siteKey: \"siteKey\",\n          theme: \"theme\",\n          type: \"type\",\n          size: \"size\",\n          tabIndex: \"tabIndex\",\n          badge: \"badge\",\n          errorMode: \"errorMode\"\n        },\n        outputs: {\n          resolved: \"resolved\",\n          error: \"error\",\n          errored: \"errored\"\n        },\n        exportAs: [\"reCaptcha\"],\n        decls: 0,\n        vars: 0,\n        template: function RecaptchaComponent_Template(rf, ctx) {},\n        encapsulation: 2\n      });\n    }\n  }\n  return RecaptchaComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RecaptchaCommonModule = /*#__PURE__*/(() => {\n  class RecaptchaCommonModule {\n    static {\n      this.ɵfac = function RecaptchaCommonModule_Factory(t) {\n        return new (t || RecaptchaCommonModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: RecaptchaCommonModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return RecaptchaCommonModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RecaptchaModule = /*#__PURE__*/(() => {\n  class RecaptchaModule {\n    static {\n      this.ɵfac = function RecaptchaModule_Factory(t) {\n        return new (t || RecaptchaModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: RecaptchaModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n        providers: [RecaptchaLoaderService],\n        imports: [RecaptchaCommonModule]\n      });\n    }\n  }\n  return RecaptchaModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The main service for working with reCAPTCHA v3 APIs.\n *\n * Use the `execute` method for executing a single action, and\n * `onExecute` observable for listening to all actions at once.\n */\nlet ReCaptchaV3Service = /*#__PURE__*/(() => {\n  class ReCaptchaV3Service {\n    constructor(zone, recaptchaLoader, siteKey) {\n      this.recaptchaLoader = recaptchaLoader;\n      this.zone = zone;\n      this.siteKey = siteKey;\n      this.init();\n    }\n    get onExecute() {\n      if (!this.onExecuteSubject) {\n        this.onExecuteSubject = new Subject();\n        this.onExecuteObservable = this.onExecuteSubject.asObservable();\n      }\n      return this.onExecuteObservable;\n    }\n    get onExecuteError() {\n      if (!this.onExecuteErrorSubject) {\n        this.onExecuteErrorSubject = new Subject();\n        this.onExecuteErrorObservable = this.onExecuteErrorSubject.asObservable();\n      }\n      return this.onExecuteErrorObservable;\n    }\n    /**\n     * Executes the provided `action` with reCAPTCHA v3 API.\n     * Use the emitted token value for verification purposes on the backend.\n     *\n     * For more information about reCAPTCHA v3 actions and tokens refer to the official documentation at\n     * https://developers.google.com/recaptcha/docs/v3.\n     *\n     * @param {string} action the action to execute\n     * @returns {Observable<string>} an `Observable` that will emit the reCAPTCHA v3 string `token` value whenever ready.\n     * The returned `Observable` completes immediately after emitting a value.\n     */\n    execute(action) {\n      const subject = new Subject();\n      if (!this.grecaptcha) {\n        if (!this.actionBacklog) {\n          this.actionBacklog = [];\n        }\n        this.actionBacklog.push([action, subject]);\n      } else {\n        this.executeActionWithSubject(action, subject);\n      }\n      return subject.asObservable();\n    }\n    /** @internal */\n    executeActionWithSubject(action, subject) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const onError = error => {\n        this.zone.run(() => {\n          subject.error(error);\n          if (this.onExecuteErrorSubject) {\n            // We don't know any better at this point, unfortunately, so have to resort to `any`\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.onExecuteErrorSubject.next({\n              action,\n              error\n            });\n          }\n        });\n      };\n      this.zone.runOutsideAngular(() => {\n        try {\n          this.grecaptcha.execute(this.siteKey, {\n            action\n          }).then(token => {\n            this.zone.run(() => {\n              subject.next(token);\n              subject.complete();\n              if (this.onExecuteSubject) {\n                this.onExecuteSubject.next({\n                  action,\n                  token\n                });\n              }\n            });\n          }, onError);\n        } catch (e) {\n          onError(e);\n        }\n      });\n    }\n    /** @internal */\n    init() {\n      this.recaptchaLoader.ready.subscribe(value => {\n        this.grecaptcha = value;\n        if (this.actionBacklog && this.actionBacklog.length > 0) {\n          this.actionBacklog.forEach(([action, subject]) => this.executeActionWithSubject(action, subject));\n          this.actionBacklog = undefined;\n        }\n      });\n    }\n    static {\n      this.ɵfac = function ReCaptchaV3Service_Factory(t) {\n        return new (t || ReCaptchaV3Service)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(RecaptchaLoaderService), i0.ɵɵinject(RECAPTCHA_V3_SITE_KEY));\n      };\n    }\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: ReCaptchaV3Service,\n        factory: ReCaptchaV3Service.ɵfac\n      });\n    }\n  }\n  return ReCaptchaV3Service;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RecaptchaV3Module = /*#__PURE__*/(() => {\n  class RecaptchaV3Module {\n    static {\n      this.ɵfac = function RecaptchaV3Module_Factory(t) {\n        return new (t || RecaptchaV3Module)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: RecaptchaV3Module\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n        providers: [ReCaptchaV3Service, RecaptchaLoaderService]\n      });\n    }\n  }\n  return RecaptchaV3Module;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RecaptchaValueAccessorDirective = /*#__PURE__*/(() => {\n  class RecaptchaValueAccessorDirective {\n    constructor(host) {\n      this.host = host;\n      this.requiresControllerReset = false;\n    }\n    writeValue(value) {\n      if (!value) {\n        this.host.reset();\n      } else {\n        // In this case, it is most likely that a form controller has requested to write a specific value into the component.\n        // This isn't really a supported case - reCAPTCHA values are single-use, and, in a sense, readonly.\n        // What this means is that the form controller has recaptcha control state of X, while reCAPTCHA itself can't \"restore\"\n        // to that state. In order to make form controller aware of this discrepancy, and to fix the said misalignment,\n        // we'll be telling the controller to \"reset\" the value back to null.\n        if (this.host.__unsafe_widgetValue !== value && Boolean(this.host.__unsafe_widgetValue) === false) {\n          this.requiresControllerReset = true;\n        }\n      }\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n      if (this.requiresControllerReset) {\n        this.requiresControllerReset = false;\n        this.onChange(null);\n      }\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    onResolve($event) {\n      if (this.onChange) {\n        this.onChange($event);\n      }\n      if (this.onTouched) {\n        this.onTouched();\n      }\n    }\n    static {\n      this.ɵfac = function RecaptchaValueAccessorDirective_Factory(t) {\n        return new (t || RecaptchaValueAccessorDirective)(i0.ɵɵdirectiveInject(RecaptchaComponent));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: RecaptchaValueAccessorDirective,\n        selectors: [[\"re-captcha\", \"formControlName\", \"\"], [\"re-captcha\", \"formControl\", \"\"], [\"re-captcha\", \"ngModel\", \"\"]],\n        hostBindings: function RecaptchaValueAccessorDirective_HostBindings(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵlistener(\"resolved\", function RecaptchaValueAccessorDirective_resolved_HostBindingHandler($event) {\n              return ctx.onResolve($event);\n            });\n          }\n        },\n        features: [i0.ɵɵProvidersFeature([{\n          multi: true,\n          provide: NG_VALUE_ACCESSOR,\n          useExisting: forwardRef(() => RecaptchaValueAccessorDirective)\n        }])]\n      });\n    }\n  }\n  return RecaptchaValueAccessorDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RecaptchaFormsModule = /*#__PURE__*/(() => {\n  class RecaptchaFormsModule {\n    static {\n      this.ɵfac = function RecaptchaFormsModule_Factory(t) {\n        return new (t || RecaptchaFormsModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: RecaptchaFormsModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n        imports: [FormsModule, RecaptchaCommonModule]\n      });\n    }\n  }\n  return RecaptchaFormsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RECAPTCHA_BASE_URL, RECAPTCHA_LANGUAGE, RECAPTCHA_LOADER_OPTIONS, RECAPTCHA_NONCE, RECAPTCHA_SETTINGS, RECAPTCHA_V3_SITE_KEY, ReCaptchaV3Service, RecaptchaComponent, RecaptchaFormsModule, RecaptchaLoaderService, RecaptchaModule, RecaptchaV3Module, RecaptchaValueAccessorDirective };\n//# sourceMappingURL=ng-recaptcha.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}